# Thread-Safety in Java: Bank Account Example

## 📌 개요
멀티스레드 환경에서 **공유 자원(Shared Resource)** 에 동시에 접근하면 데이터 불일치(Data Inconsistency) 문제가 발생할 수 있습니다.  

이 예제에서는 **은행 계좌(BankAccount)** 를 두 개의 스레드가 동시에 출금하려 할 때 발생하는 문제와, 이를 해결하는 방법을 비교합니다.

---

## 1. 문제 상황: 동기화 없이 접근

- **상황**  
  하나의 `BankAccount` 객체를 두 개의 스레드가 동시에 출금 요청.
- **문제**  
  두 스레드가 동시에 **검증 로직**(잔액 확인)을 통과하여 출금을 하면, 계좌 잔액이 음수가 될 수 있다.
- **예시(BankAccountV1)**  
  은행 잔고: 1000  
  t1: 출금요청: 800(성공)  
  t2: 출금요청: 800(성공)  
  결과: 잔액: -600 


## 2. `synchronized` 키워드 사용

- **원리**  
  method 나 block에 `synchronized`를 적용하여 **한번에 하나의 스레드만** 해당 코드에 진입하도록 보장합니다.
- **장점**  
  구현이 간단하고, 코드 변경이 적다.
- **단점**  
  - 무한대기. 
  - 공정성 문제.
- **예시(BankAccountV2)**  
  은행 잔고: 1000  
  t1: 출금요청: 800(성공)  
  t2: 출금요청: 800(실패)  
  잔액: 200 


## 3. Lock 사용

- **원리**  
  `synchronized`의 단점을 보완하여 Java 1.5부터 나온 Lock 인터페이스 사용.
- **장점**  
  - 다른 쓰레드가 이미 락을 획득 했다면, 락이 풀릴때까지 무한대기하는 문제는 tryLock을 통해 해결됨.
  - ReentrantLock의 constructor에 true를 넣으면 공정모드를 제공한다. 이는 먼저 대기한 스레드가 먼저 락을 획득하도록 보장한다. 하지만 그로인해 성능이 저하될 수 있다.
  
- **단점**
    - lock.unlock을 잘 지정하지 않으면 데드락 상황 발생.
    - 공정성 해결 가능하나, 성능 저하 될 수 있음.
- **예시(BankAccountV3)**  
  은행 잔고: 1000  
  t1: 출금요청: 800(성공)  
  t2: 출금요청: 800(실패)  
  잔액: 200
